<?xml version="1.0"?>
<!DOCTYPE bindings SYSTEM "chrome://consolelogger/locale/options.dtd">
<bindings id="consoleLogger-bindings"
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	<binding id="consoleLoggerItem">
		<content>
			<children />
			<xul:grid flex="1">
				<xul:columns>
					<xul:column />
					<xul:column flex="1" />
				</xul:columns>
				<xul:rows>
					<xul:row align="center" class="cl-row-main">
						<xul:label value="&cl.name;" />
						<xul:hbox align="center">
							<xul:textbox anonid="name" flex="1" />
							<xul:checkbox anonid="enabled" class="cl-enabled" label="&cl.enabled;" />
						</xul:hbox>
					</xul:row>
					<xul:row align="center" class="cl-row-detail">
						<xul:label value="&cl.sourcePattern;" />
						<xul:textbox anonid="source" flex="1" />
					</xul:row>
					<xul:row align="center" class="cl-row-detail">
						<xul:label value="&cl.messagePattern;" />
						<xul:textbox anonid="message" flex="1" />
					</xul:row>
					<xul:row align="center" class="cl-row-detail">
						<xul:label value="&cl.excludePattern;" />
						<xul:textbox anonid="exclude" flex="1" />
					</xul:row>
				</xul:rows>
			</xul:grid>
		</content>
		<implementation implements="nsIDOMEventListener">
			<constructor>
				this._elts = { __proto__: null };
				var nameBox = this.getItem("name");
				nameBox.addEventListener("keypress", this, false);
				nameBox.addEventListener("input", this, false);
				if("ondrop" in nameBox) // Firefox 4+
					nameBox.addEventListener("drop", this, false);
				else {
					nameBox.addEventListener("dragexit", this, false);
					nameBox.addEventListener("dragend", this, false);
				}
			</constructor>
			<destructor>
				var nameBox = this.getItem("name");
				nameBox.removeEventListener("keypress", this, false);
				nameBox.removeEventListener("input",    this, false);
				nameBox.removeEventListener("drop",     this, false);
				nameBox.removeEventListener("dragexit", this, false);
				nameBox.removeEventListener("dragend",  this, false);
			</destructor>
			<method name="handleEvent">
				<parameter name="event" />
				<body>
					if(event.currentTarget.getAttribute("anonid") == "name")
						this.validateName(event);
				</body>
			</method>
			<field name="params">["name", "enabled", "source", "message", "exclude"]</field>
			<method name="getItem">
				<parameter name="anonId" />
				<body>
					return this._elts[anonId] || (
						this._elts[anonId] = this.ownerDocument.getAnonymousElementByAttribute(this, "anonid", anonId)
					);
				</body>
			</method>
			<property name="name"
				onget="return this.getItem('name').value;"
				onset="this.getItem('name').value = val;" />
			<property name="enabled"
				onget="return this.getItem('enabled').checked;"
				onset="this.getItem('enabled').checked = val;" />
			<property name="locked"
				onget="return this.getItem('name').disabled;"
				onset="this.getItem('name').disabled = val;" />
			<property name="state">
				<getter>
					var state = { __proto__: null };
					this.params.forEach(function(name) {
						var elt = this.getItem(name);
						state[name] = "checked" in elt ? elt.checked : elt.value;
					}, this);
					state.locked = this.getItem("name").disabled;
					return state;
				</getter>
				<setter>
				<![CDATA[
					var state = val;
					for(var name in state) if(Object.hasOwnProperty.call(state, name)) {
						var elt = this.getItem(name);
						if(!elt)
							continue;
						if("checked" in elt)
							elt.checked = state[name];
						else {
							var v = state[name];
							if(name == "name" && !this.isValidName(v)) {
								v = this.fixName(v);
								this.showValidNameTip(elt, true);
							}
							elt.value = v;
						}
					}
					if("locked" in state && state.locked)
						this.getItem("name").disabled = true;
				]]>
				</setter>
			</property>
			<method name="focus">
				<body>
					var nameField = this.getItem("name").inputField;
					nameField.focus();
					nameField.select();
				</body>
			</method>
			<method name="setFilter">
				<parameter name="matcher" />
				<body>
				<![CDATA[
					var matched = false;
					this.params.forEach(function(name) {
						var elt = this.getItem(name);
						if("checked" in elt)
							return;
						if(matcher && matcher(elt.value))
							elt.setAttribute("cl_highlight", "true"), matched = true;
						else
							elt.removeAttribute("cl_highlight");
					}, this);
					return matched;
				]]>
				</body>
			</method>
			<field name="_checkNameTimer">0</field>
			<method name="validateName">
				<parameter name="event" />
				<body>
				<![CDATA[
					var nameBox = event.currentTarget;
					if(event.type == "keypress") {
						var key = event.charCode || 0;
						if(
							key >= 0 && key <= 127 // US-ASCII (includes control characters)
							|| event.ctrlKey || event.altKey || event.metaKey // Some hotkey
						)
							return;
						event.preventDefault();
						this.showValidNameTip(nameBox);
						return;
					}
					// Wait for changes (and don't call too often)
					clearTimeout(this._checkNameTimer);
					this._checkNameTimer = setTimeout(function(_this) {
						_this.checkName(nameBox);
					}, 0, this);
				]]>
				</body>
			</method>
			<method name="checkName">
				<parameter name="nameBox" />
				<body>
				<![CDATA[
					var nameField = nameBox.inputField;
					var curVal = nameField.value;
					if(this.isValidName(curVal))
						return;
					try {
						var editor = nameField
							.QueryInterface(Components.interfaces.nsIDOMNSEditableElement)
							.editor
							.QueryInterface(Components.interfaces.nsIEditor);
						var undoEnabled = { value: false };
						var canUndo = { value: false };
						editor.canUndo(undoEnabled, canUndo);
						if(!undoEnabled.value || !canUndo.value)
							throw new Error("nsIEditor: can't undo");
						editor.undo(1);
						var sc = editor.selectionController;
						sc.scrollSelectionIntoView(
							sc.SELECTION_NORMAL,
							sc.SELECTION_ANCHOR_REGION,
							true
						);
					}
					catch(e) {
						Components.utils.reportError(e);
						var ss = this.fixName(curVal.substr(0, nameField.selectionStart)).length;
						var se = this.fixName(curVal.substr(0, nameField.selectionEnd)).length;
						nameField.value = this.fixName(curVal);
						nameField.selectionStart = ss;
						nameField.selectionEnd = se;
					}
					this.showValidNameTip(nameBox);
				]]>
				</body>
			</method>
			<method name="isValidName">
				<parameter name="name" />
				<body>
					return !/[^\x20-\x7e]/.test(name);
				</body>
			</method>
			<method name="fixName">
				<parameter name="name" />
				<body>
					return name.replace(/[^\x20-\x7e]+/g, "");
				</body>
			</method>
			<field name="_hideNameTipTimer">0</field>
			<method name="showValidNameTip">
				<parameter name="nameBox" />
				<parameter name="highlight" />
				<body>
					var tt = document.getElementById("cl-tt-validName");
					if(!tt) {
						tt = document.createElement("tooltip");
						tt.id = "cl-tt-validName";
						tt.style.margin = 0;
						tt.setAttribute("label", "&cl.onlyASCII;");
						document.documentElement.appendChild(tt);
					}
					if(highlight)
						nameBox.setAttribute("cl_invalid", "true");
					var bo = nameBox.boxObject;
					var x = bo.screenX;
					var y = bo.screenY + bo.height + 2;
					if("openPopupAtScreen" in tt) // Firefox 3.0+
						tt.openPopupAtScreen(x, y, false /*isContextMenu*/);
					else
						tt.showPopup(nameBox, x, y, "tooltip", null, null);
					clearTimeout(this._hideNameTipTimer);
					this._hideNameTipTimer = setTimeout(function() {
						if(highlight)
							nameBox.removeAttribute("cl_invalid");
						tt.hidePopup();
					}, 1000);
				</body>
			</method>
		</implementation>
	</binding>
</bindings>